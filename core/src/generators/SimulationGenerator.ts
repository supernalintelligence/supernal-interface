/**
 * Simulation Generator - Generates TypeScript simulation code
 */

import { ComponentInfo, ElementType, ActionType } from '../types';
import { ComponentUsage } from '../discovery/ComponentScanner';
import { InferenceEngine } from '../discovery/InferenceEngine';
import * as fs from 'fs/promises';
import * as path from 'path';

export class SimulationGenerator {
  private inferenceEngine = new InferenceEngine();

  /**
   * Generate simulation methods from component names and usage data
   */
  generateMethods(componentNames: Map<string, string>, componentUsage: Map<string, ComponentUsage>): ComponentInfo[] {
    const methods: ComponentInfo[] = [];
    
    for (const [testId, constantName] of componentNames) {
      const usage = componentUsage.get(testId);
      const inference = this.inferenceEngine.inferHybrid(constantName, testId, usage);
      const methodName = this.inferenceEngine.generateMethodName(constantName, inference.actionType);
      
      methods.push({
        constantName,
        testId,
        elementType: inference.elementType,
        actionType: inference.actionType,
        methodName,
        confidence: inference.confidence,
        source: inference.source
      });
    }
    
    return methods;
  }

  /**
   * Generate TypeScript simulation class code
   */
  async generate(componentNames: Map<string, string>, componentUsage: Map<string, ComponentUsage>, templatePath?: string): Promise<string> {
    const methods = this.generateMethods(componentNames, componentUsage);
    
    if (templatePath) {
      return await this.generateFromTemplate(methods, templatePath);
    }
    
    return this.generateDefault(methods);
  }

  /**
   * Generate simulation using custom template
   */
  private async generateFromTemplate(methods: ComponentInfo[], templatePath: string): Promise<string> {
    try {
      const template = await fs.readFile(templatePath, 'utf8');
      
      // Simple template replacement
      const methodsCode = methods.map(method => this.generateMethodCode(method)).join('\n\n');
      
      return template
        .replace('{{METHODS}}', methodsCode)
        .replace('{{TIMESTAMP}}', new Date().toISOString())
        .replace('{{METHOD_COUNT}}', methods.length.toString());
        
    } catch (error) {
      throw new Error(`Failed to load template: ${error instanceof Error ? error.message : String(error)}`);
    }
  }

  /**
   * Generate simulation using default template
   */
  private generateDefault(methods: ComponentInfo[]): Promise<string> {
    const methodsCode = methods.map(method => this.generateMethodCode(method)).join('\n\n');
    const semanticActions = this.generateSemanticActions(methods);
    const reduxStateMethods = this.generateReduxStateMethods();
    
    const code = `/**
 * Auto-generated SidebarSimulation
 * Generated from ComponentNames.ts - DO NOT EDIT MANUALLY
 * 
 * Generated: ${new Date().toISOString()}
 * Methods: ${methods.length}
 * 
 * Enhanced with proven patterns from working SidebarSimulation:
 * - Robust selectors with fallbacks
 * - Semantic high-level actions
 * - Proper Playwright patterns (.type() vs .fill())
 * - Error handling with fallbacks
 * - Auto-generated Redux state inspection (eliminates getReduxState duplication)
 */

import { Page, Frame, FrameLocator } from '@playwright/test';

export class AutoGeneratedSidebarSimulation {
  constructor(private context: Page | Frame | FrameLocator) {}

  // === SEMANTIC HIGH-LEVEL ACTIONS ===
  // These combine multiple low-level actions into meaningful workflows
${semanticActions}

  // === REDUX STATE INSPECTION ===
  // Auto-generated methods to eliminate getReduxState duplication
${reduxStateMethods}

  // === AUTO-GENERATED COMPONENT METHODS ===
  // Generated from ComponentNames.ts constants
${methodsCode}

  // === ROBUST HELPER METHODS ===
  // Enhanced with fallback selectors and proper Playwright patterns
  
  private async clickElement(testId: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Primary selector with fallbacks for robustness
      const selectors = [
        \`[data-testid="\${testId}"]\`,
        \`#\${testId}\`,
        \`.\${testId}\`
      ];
      
      for (const selector of selectors) {
        try {
          const element = this.context.locator(selector);
          await element.waitFor({ state: 'visible', timeout: 5000 });
          await element.click();
          return { success: true };
        } catch (e) {
          continue; // Try next selector
        }
      }
      
      throw new Error(\`Element not found with any selector for testId: \${testId}\`);
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }

  private async typeInElement(testId: string, text: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Enhanced selectors for input elements
      const selectors = [
        \`[data-testid="\${testId}"]\`,
        \`#\${testId}\`,
        'textarea, input[type="text"]' // Generic fallback
      ];
      
      for (const selector of selectors) {
        try {
          const element = this.context.locator(selector);
          await element.waitFor({ state: 'visible', timeout: 5000 });
          await element.clear();
          // Use .type() instead of .fill() to trigger React onChange events
          await element.type(text);
          return { success: true };
        } catch (e) {
          continue;
        }
      }
      
      throw new Error(\`Input element not found for testId: \${testId}\`);
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }

  private async selectOption(testId: string, value: string): Promise<{ success: boolean; error?: string }> {
    try {
      const selectors = [
        \`[data-testid="\${testId}"]\`,
        \`#\${testId}\`,
        'select'
      ];
      
      for (const selector of selectors) {
        try {
          const element = this.context.locator(selector);
          await element.waitFor({ state: 'visible', timeout: 5000 });
          await element.selectOption(value);
          return { success: true };
        } catch (e) {
          continue;
        }
      }
      
      throw new Error(\`Select element not found for testId: \${testId}\`);
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }

  private async toggleElement(testId: string): Promise<{ success: boolean; error?: string }> {
    return await this.clickElement(testId); // Toggle is just a click
  }

  private async interactWithElement(testId: string): Promise<{ success: boolean; error?: string }> {
    return await this.clickElement(testId); // Generic interaction is a click
  }
}

// Factory function for easy usage
export function createAutoGeneratedSidebarSimulation(context: Page | Frame | FrameLocator): AutoGeneratedSidebarSimulation {
  return new AutoGeneratedSidebarSimulation(context);
}`;

    return Promise.resolve(code);
  }

  /**
   * Generate semantic high-level actions that combine multiple low-level actions
   */
  private generateSemanticActions(methods: ComponentInfo[]): string {
    // Find key components for semantic actions
    const chatInput = methods.find(m => m.testId === 'supernal-chat-input');
    const chatSendButton = methods.find(m => m.testId === 'supernal-chat-send-button');
    const newChatButton = methods.find(m => m.testId === 'supernal-new-chat-button');
    
    let semanticActions = '';
    
    // Generate sendMessage action if we have both input and send button
    if (chatInput && chatSendButton) {
      semanticActions += `
  /**
   * High-level semantic action: Send a chat message
   * Combines typing in input + sending (with fallbacks)
   */
  async sendMessage(message: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Step 0: Wait for chat input to be ready (auto-initialization takes time)
      const waitResult = await this.waitForChatInput(10000);
      if (!waitResult.success) {
        return { success: false, error: \`Chat input not ready: \${waitResult.error}\` };
      }
      
      // Step 1: Type the message
      const typeResult = await this.${chatInput.methodName}(message);
      if (!typeResult.success) {
        return { success: false, error: \`Failed to type message: \${typeResult.error}\` };
      }
      
      // Step 2: Send the message (try Enter key first, then button)
      try {
        // Try Enter key first (most reliable)
        await this.context.locator('[data-testid="supernal-chat-input"]').press('Enter');
        return { success: true };
      } catch (enterError) {
        // Fallback to send button
        const sendResult = await this.${chatSendButton.methodName}();
        if (!sendResult.success) {
          return { success: false, error: \`Failed to send message: \${sendResult.error}\` };
        }
        return { success: true };
      }
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }`;
    }
    
    // Generate createNewChat action if we have new chat button
    if (newChatButton) {
      semanticActions += `
  
  /**
   * High-level semantic action: Create a new chat
   */
  async createNewChat(): Promise<{ success: boolean; error?: string }> {
    return await this.${newChatButton.methodName}();
  }`;
    }
    
    // Generate combined action: create new chat and send message
    if (newChatButton && chatInput && chatSendButton) {
      semanticActions += `
  
  /**
   * High-level semantic action: Create new chat and send first message
   */
  async createNewChatWithMessage(message: string): Promise<{ success: boolean; error?: string }> {
    try {
      // Step 1: Create new chat
      const newChatResult = await this.createNewChat();
      if (!newChatResult.success) {
        return { success: false, error: \`Failed to create new chat: \${newChatResult.error}\` };
      }
      
      // Step 2: Wait a moment for chat to be ready
      await new Promise(resolve => setTimeout(resolve, 500));
      
      // Step 3: Send the message
      return await this.sendMessage(message);
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }`;
    }
    
    return semanticActions;
  }

  /**
   * Generate Redux state inspection methods
   */
  private generateReduxStateMethods(): string {
    return `
  /**
   * Auto-generated Redux state inspection
   * Eliminates duplication of getReduxState functions across tests
   */
  async getReduxState(): Promise<{
    hasStore: boolean;
    chats: any[];
    chatCount: number;
    workspaces: any[];
    workspaceCount: number;
    activeChatId?: string;
    activeWorkspaceId?: string;
    messageCount: number;
    allMessages: number;
    error?: string;
  }> {
    try {
      const state = await this.context.evaluate(() => {
        if (window.__REDUX_STORE__) {
          const state = window.__REDUX_STORE__.getState();
          
          const chats = state.workspace?.chats || [];
          const workspaces = state.workspace?.availableWorkspaces || [];
          
          // Count all messages across all chats
          let totalMessages = 0;
          chats.forEach(chat => {
            if (chat.messages && Array.isArray(chat.messages)) {
              totalMessages += chat.messages.length;
            }
          });
          
          return {
            hasStore: true,
            chats,
            chatCount: chats.length,
            workspaces,
            workspaceCount: workspaces.length,
            activeChatId: state.workspace?.activeChatId,
            activeWorkspaceId: state.workspace?.activeWorkspaceId,
            messageCount: totalMessages,
            allMessages: totalMessages
          };
        } else {
          return {
            hasStore: false,
            chats: [],
            chatCount: 0,
            workspaces: [],
            workspaceCount: 0,
            messageCount: 0,
            allMessages: 0
          };
        }
      });
      
      return state;
    } catch (error) {
      return {
        hasStore: false,
        chats: [],
        chatCount: 0,
        workspaces: [],
        workspaceCount: 0,
        messageCount: 0,
        allMessages: 0,
        error: error instanceof Error ? error.message : String(error)
      };
    }
  }

  /**
   * Wait for Redux store to be available
   */
  async waitForReduxStore(timeout: number = 10000): Promise<{ success: boolean; error?: string }> {
    try {
      const startTime = Date.now();
      
      while (Date.now() - startTime < timeout) {
        const state = await this.getReduxState();
        if (state.hasStore) {
          return { success: true };
        }
        await new Promise(resolve => setTimeout(resolve, 100));
      }
      
      return { success: false, error: 'Redux store not available within timeout' };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }

  /**
   * Verify expected state conditions
   */
  async verifyState(conditions: {
    minChats?: number;
    maxChats?: number;
    minMessages?: number;
    hasActiveChat?: boolean;
    hasActiveWorkspace?: boolean;
  }): Promise<{ success: boolean; error?: string; state?: any }> {
    try {
      const state = await this.getReduxState();
      
      if (!state.hasStore) {
        return { success: false, error: 'Redux store not available', state };
      }
      
      if (conditions.minChats !== undefined && state.chatCount < conditions.minChats) {
        return { 
          success: false, 
          error: \`Expected at least \${conditions.minChats} chats, got \${state.chatCount}\`,
          state 
        };
      }
      
      if (conditions.maxChats !== undefined && state.chatCount > conditions.maxChats) {
        return { 
          success: false, 
          error: \`Expected at most \${conditions.maxChats} chats, got \${state.chatCount}\`,
          state 
        };
      }
      
      if (conditions.minMessages !== undefined && state.messageCount < conditions.minMessages) {
        return { 
          success: false, 
          error: \`Expected at least \${conditions.minMessages} messages, got \${state.messageCount}\`,
          state 
        };
      }
      
      if (conditions.hasActiveChat && !state.activeChatId) {
        return { 
          success: false, 
          error: 'Expected active chat but none found',
          state 
        };
      }
      
      if (conditions.hasActiveWorkspace && !state.activeWorkspaceId) {
        return { 
          success: false, 
          error: 'Expected active workspace but none found',
          state 
        };
      }
      
      return { success: true, state };
    } catch (error) {
      return { 
        success: false, 
        error: error instanceof Error ? error.message : String(error) 
      };
    }
  }

  /**
   * Wait for chat input to be ready (auto-initialization takes time)
   * Based on working SidebarSimulation.verifyChatInputIsFocused
   */
  async waitForChatInput(timeout: number = 10000): Promise<{ success: boolean; error?: string }> {
    try {
      // Try multiple selectors like the working system does
      const selectors = [
        '#supernal-chat-input',  // ID selector (primary in working system)
        '[data-testid="supernal-chat-input"]',  // data-testid selector
        'textarea, input[type="text"]'  // Generic fallback
      ];
      
      for (const selector of selectors) {
        try {
          const element = this.context.locator(selector);
          await element.waitFor({ state: 'visible', timeout });
          return { success: true };
        } catch (e) {
          continue;
        }
      }
      
      return { success: false, error: 'Chat input not found with any selector after timeout' };
    } catch (error) {
      return { success: false, error: error instanceof Error ? error.message : String(error) };
    }
  }`;
  }

  /**
   * Generate individual method code
   */
  private generateMethodCode(method: ComponentInfo): string {
    const { methodName, testId, actionType, elementType, confidence, source } = method;
    
    const comment = `  // ${method.constantName} → ${elementType} (${confidence}% confidence, ${source})`;
    
    switch (actionType) {
      case 'click':
        return `${comment}
  async ${methodName}(): Promise<{ success: boolean; error?: string }> {
    return await this.clickElement('${testId}');
  }`;
      
      case 'type':
        return `${comment}
  async ${methodName}(text: string): Promise<{ success: boolean; error?: string }> {
    return await this.typeInElement('${testId}', text);
  }`;
      
      case 'select':
        return `${comment}
  async ${methodName}(value: string): Promise<{ success: boolean; error?: string }> {
    return await this.selectOption('${testId}', value);
  }`;
      
      case ActionType.CLICK: // Handle toggle as click
        return `${comment}
  async ${methodName}(): Promise<{ success: boolean; error?: string }> {
    return await this.toggleElement('${testId}');
  }`;
      
      default:
        return `${comment}
  async ${methodName}(): Promise<{ success: boolean; error?: string }> {
    return await this.interactWithElement('${testId}');
  }`;
    }
  }
}
