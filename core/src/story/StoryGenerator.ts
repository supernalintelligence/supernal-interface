/**
 * Story Generator - Creates SimpleStories using auto-generated simulation methods
 */

import { ComponentInfo } from '../types';

export interface StoryStep {
  action: string;           // Method name from auto-generated simulation
  params?: any[];          // Parameters to pass to the method
  description?: string;    // Human-readable description
  validation?: string;     // Optional validation method
}

export interface Story {
  name: string;
  description: string;
  steps: StoryStep[];
}

export interface StoryTemplate {
  name: string;
  description: string;
  stepTemplates: Array<{
    actionPattern: string;    // Pattern to match against available methods
    params?: any[];
    description?: string;
    validation?: string;
  }>;
}

export class StoryGenerator {
  
  /**
   * Generate stories from templates using available simulation methods
   */
  generateStories(availableMethods: ComponentInfo[], templates: StoryTemplate[]): Story[] {
    const stories: Story[] = [];
    
    for (const template of templates) {
      const story = this.generateStoryFromTemplate(template, availableMethods);
      if (story) {
        stories.push(story);
      }
    }
    
    return stories;
  }

  /**
   * Generate a single story from template
   */
  private generateStoryFromTemplate(template: StoryTemplate, availableMethods: ComponentInfo[]): Story | null {
    const steps: StoryStep[] = [];
    
    for (const stepTemplate of template.stepTemplates) {
      const matchingMethod = this.findMatchingMethod(stepTemplate.actionPattern, availableMethods);
      
      if (matchingMethod) {
        steps.push({
          action: matchingMethod.methodName,
          params: stepTemplate.params,
          description: stepTemplate.description || `Execute ${matchingMethod.methodName}`,
          validation: stepTemplate.validation
        });
      } else {
        // Skip story if required method not found
        console.warn(`‚ö†Ô∏è Story "${template.name}" skipped: No method found for pattern "${stepTemplate.actionPattern}"`);
        return null;
      }
    }
    
    return {
      name: template.name,
      description: template.description,
      steps
    };
  }

  /**
   * Find method matching a pattern
   */
  private findMatchingMethod(pattern: string, availableMethods: ComponentInfo[]): ComponentInfo | null {
    // Exact match first
    let match = availableMethods.find(method => method.methodName === pattern);
    if (match) return match;
    
    // Pattern matching (e.g., "*ChatInput" matches "typeChatInput")
    if (pattern.includes('*')) {
      const regex = new RegExp(pattern.replace('*', '.*'), 'i');
      match = availableMethods.find(method => regex.test(method.methodName));
      if (match) return match;
    }
    
    // Fuzzy matching by element type and action
    if (pattern.includes(':')) {
      const [actionType, elementPattern] = pattern.split(':');
      match = availableMethods.find(method => 
        method.actionType === actionType && 
        method.methodName.toLowerCase().includes(elementPattern.toLowerCase())
      );
      if (match) return match;
    }
    
    return null;
  }

  /**
   * Generate TypeScript code for stories
   */
  generateStoryCode(stories: Story[]): string {
    const storyDefinitions = stories.map(story => {
      const steps = story.steps.map(step => {
        const params = step.params ? `, ${JSON.stringify(step.params).slice(1, -1)}` : '';
        return `    {
      action: '${step.action}',
      params: [${step.params?.map(p => JSON.stringify(p)).join(', ') || ''}],
      description: '${step.description}'${step.validation ? `,\n      validation: '${step.validation}'` : ''}
    }`;
      }).join(',\n');

      return `  ${story.name}: {
    description: '${story.description}',
    steps: [
${steps}
    ]
  }`;
    }).join(',\n\n');

    return `/**
 * Auto-generated SimpleStories
 * Generated from ComponentNames.ts - DO NOT EDIT MANUALLY
 * 
 * Generated: ${new Date().toISOString()}
 * Stories: ${stories.length}
 */

export interface StoryStep {
  action: string;
  params?: any[];
  description?: string;
  validation?: string;
}

export interface Story {
  description: string;
  steps: StoryStep[];
}

export const AUTO_GENERATED_STORIES: Record<string, Story> = {
${storyDefinitions}
};

/**
 * Execute a story using the auto-generated simulation
 */
export async function executeAutoGeneratedStory(
  simulation: any, 
  storyName: string, 
  page?: any
): Promise<{ success: boolean; message?: string; error?: string }> {
  const story = AUTO_GENERATED_STORIES[storyName];
  if (!story) {
    return { 
      success: false, 
      error: \`Story "\${storyName}" not found. Available: \${Object.keys(AUTO_GENERATED_STORIES).join(', ')}\`
    };
  }

  console.log(\`üé≠ Executing auto-generated story: "\${storyName}"\`);
  
  try {
    for (const [index, step] of story.steps.entries()) {
      console.log(\`  üìù Step \${index + 1}: \${step.description}\`);
      
      const method = simulation[step.action];
      if (!method) {
        throw new Error(\`Method "\${step.action}" not found in simulation\`);
      }
      
      const result = await method.apply(simulation, step.params || []);
      
      if (result && !result.success) {
        throw new Error(\`Step failed: \${result.error || 'Unknown error'}\`);
      }
      
      // Optional validation
      if (step.validation && simulation[step.validation]) {
        const validationResult = await simulation[step.validation]();
        if (validationResult && !validationResult.success) {
          throw new Error(\`Validation failed: \${validationResult.error || 'Unknown error'}\`);
        }
      }
    }
    
    console.log(\`‚úÖ Story "\${storyName}" completed successfully\`);
    return { success: true, message: \`Story "\${storyName}" executed successfully\` };
    
  } catch (error) {
    const errorMessage = error instanceof Error ? error.message : String(error);
    console.error(\`‚ùå Story "\${storyName}" failed: \${errorMessage}\`);
    return { success: false, error: errorMessage };
  }
}`;
  }
}


